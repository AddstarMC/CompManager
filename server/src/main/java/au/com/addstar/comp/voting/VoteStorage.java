package au.com.addstar.comp.voting;

import java.util.List;
import java.util.Set;
import java.util.UUID;

import org.bukkit.entity.Player;

import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;
import com.intellectualcrafters.plot.object.Plot;

public class VoteStorage<T extends Vote> {
	private final AbstractVotingStrategy<T> strategy;
	private final AbstractVoteProvider<T> provider;
	private final SetMultimap<Plot, T> votes;
	private final SetMultimap<UUID, T> playerVotes;
	
	public VoteStorage(AbstractVotingStrategy<T> strategy) {
		Preconditions.checkNotNull(strategy);
		
		this.strategy = strategy;
		provider = strategy.createProvider(this);
		votes = HashMultimap.create();
		playerVotes = HashMultimap.create();
	}
	
	/**
	 * Records a vote by the player.
	 * Note that if revoting is not permitted, this will throw an IllegalArgumentException
	 * if you attempt to change the vote on a plot
	 * @param player The player making the vote
	 * @param vote The vote to be made
	 * @throws IllegalArgumentException Thrown if a vote for that plot has already been
	 * registered, and revoting is not permitted
	 */
	public void recordVote(Player player, T vote) throws IllegalArgumentException {
		Set<T> theirVotes = playerVotes.get(player.getUniqueId());
		for (T existing : theirVotes) {
			if (existing.getPlot().equals(vote.getPlot())) {
				if (!canPlayersRevote()) {
					throw new IllegalArgumentException("Players are not permitted to revote");
				}
				
				playerVotes.remove(player.getUniqueId(), existing);
				votes.remove(existing.getPlot(), existing.getPlot());
				break;
			}
		}
		
		playerVotes.put(player.getUniqueId(), vote);
		votes.put(vote.getPlot(), vote);
	}
	
	public boolean canPlayersRevote() {
		return strategy.allowRevote();
	}
	
	public AbstractVotingStrategy<T> getStrategy() {
		return strategy;
	}
	
	public AbstractVoteProvider<T> getProvider() {
		return provider;
	}
	
	/**
	 * Counts all the votes using the voting strategy, and resets.
	 * @return The placements generated by the strategy
	 */
	public List<Placement> countVotes() {
		SetMultimap<Plot, T> votes = HashMultimap.create(this.votes);
		this.votes.clear();
		
		return strategy.countVotes(votes);
	}
}
